<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <link href="{{ url_for('static', filename='style.css') }}" rel="stylesheet">
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>
        <div id="controls">
            <div class="control-group">
                <div class="value-display">FPS: <span id="actualFps">--</span></div>
                <div class="value-display">Step: <span id="stepDisplay">0</span></div>
                <div class="value-display">Gen: <span id="genDisplay">0</span></div>
                <div class="value-display">Best: <span id="bestDisplay">0.00</span></div>
                <div class="value-display">Mean: <span id="meanDisplay">0.00</span></div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let springs = [];
        let nSims = 1;
        let laneSpacing = 1.6;
        let finishX = 3.0;
        let xGain = 10.0;

        let positionsAll = []; // [nSims][nMasses][2]
        let comX = [];         // [nSims]
        let stepT = 0;
        let generation = 0;
        let bestFitness = 0;
        let meanFitness = 0;

        const actualFpsDisplay = document.getElementById('actualFps');
        const stepDisplay = document.getElementById('stepDisplay');
        const genDisplay = document.getElementById('genDisplay');
        const bestDisplay = document.getElementById('bestDisplay');
        const meanDisplay = document.getElementById('meanDisplay');

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function laneColor(i) {
            const palette = ['#FFD166', '#06D6A0', '#118AB2', '#EF476F', '#9B5DE5', '#F15BB5', '#00BBF9', '#FEE440'];
            return palette[i % palette.length];
        }

        let xWindow = 0.8;          // how many world units fit across the screen (zoom)
        let finishScreenRatio = 0.85; // where to place finish line (85% across)
        function worldToScreen(x, y) {
            const left = 70, right = 70, top = 50, bottom = 60;
            const usableW = canvas.width - left - right;
            const usableH = canvas.height - top - bottom;

            // Fit all lanes vertically (keep vertical scale normal)
            const totalHWorld = Math.max(1.0, (nSims - 1) * laneSpacing + 1.0);
            const scaleY = usableH / totalHWorld;

            // --- Nonlinear X mapping ---
            // Make small x look bigger: x' = min(finishX, x * xGain)
            // So:
            //   x = 0 -> left edge
            //   x = finishX -> right edge
            //   small x -> stretched visually (because multiplied by xGain)
            const xMagnified = Math.min(finishX, x * xGain);
            const scaleX = usableW / finishX;

            // Use vertical scale for Y; X uses its own scaleX
            return {
                x: left + xMagnified * scaleX,
                y: canvas.height - bottom - y * scaleY
            };
        }

        function drawGround() {
            ctx.fillStyle = '#c5d5e0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // finish line
            const fx = worldToScreen(finishX, 0).x;
            ctx.strokeStyle = '#111';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(fx, 0);
            ctx.lineTo(fx, canvas.height);
            ctx.stroke();

            ctx.fillStyle = '#111';
            ctx.font = 'bold 16px Arial';
            ctx.fillText('FINISH', fx - 35, 30);

            for (let i = 0; i < nSims; i++) {
            const yLane = i * laneSpacing + 0.02;
            const yScreen = worldToScreen(0, yLane).y;

            ctx.strokeStyle = '#4a6b80';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, yScreen);
            ctx.lineTo(canvas.width, yScreen);
            ctx.stroke();

            // tick marks
            ctx.strokeStyle = '#3d5a6b';
            ctx.lineWidth = 2;
            for (let x = 0; x <= finishX + 1.0; x += 0.5) {
                const sx = worldToScreen(x, yLane).x;
                ctx.beginPath();
                ctx.moveTo(sx, yScreen - 6);
                ctx.lineTo(sx, yScreen + 6);
                ctx.stroke();
            }
            }
        }

        function drawRobots() {
            if (!positionsAll || positionsAll.length === 0) return;

            for (let sim = 0; sim < nSims; sim++) {
            const pos = positionsAll[sim];
            if (!pos) continue;
            const yOffset = sim * laneSpacing;

            // springs
            ctx.strokeStyle = '#111';
            ctx.lineWidth = 2.5;
            for (let s = 0; s < springs.length; s++) {
                const spring = springs[s];
                const p1 = pos[spring[0]];
                const p2 = pos[spring[1]];
                if (!p1 || !p2) continue;

                const a = worldToScreen(p1[0], p1[1] + yOffset);
                const b = worldToScreen(p2[0], p2[1] + yOffset);
                ctx.beginPath();
                ctx.moveTo(a.x, a.y);
                ctx.lineTo(b.x, b.y);
                ctx.stroke();
            }

            // masses
            ctx.fillStyle = laneColor(sim);
            for (let m = 0; m < pos.length; m++) {
                const p = pos[m];
                if (!p) continue;
                const sp = worldToScreen(p[0], p[1] + yOffset);
                ctx.beginPath();
                ctx.arc(sp.x, sp.y, 4.5, 0, 2 * Math.PI);
                ctx.fill();
            }

            // COM marker (white dot) using comX from server (more accurate)
            const cx = (comX && comX[sim] !== undefined) ? comX[sim] : pos.reduce((acc, p) => acc + p[0], 0) / pos.length;
            // const com = worldToScreen(cx, 0.35 + yOffset);
            // ctx.fillStyle = '#ffffff';
            // ctx.beginPath();
            // ctx.arc(com.x, com.y, 3.5, 0, 2 * Math.PI);
            // ctx.fill();

            // BIG racer dot on the lane baseline (this is the "race position")
            const racer = worldToScreen(cx, 0.02 + yOffset);
            ctx.fillStyle = laneColor(sim);
            ctx.beginPath();
            ctx.arc(racer.x, racer.y, 8, 0, 2 * Math.PI);
            ctx.fill();

            // outline so it pops
            ctx.strokeStyle = '#111';
            ctx.lineWidth = 2;
            ctx.stroke();

            // lane label + current x
            ctx.fillStyle = '#111';
            ctx.font = '12px Arial';
            const labelPos = worldToScreen(0.08, 0.70 + yOffset);
            ctx.fillText(`#${sim}  x=${cx.toFixed(2)}`, labelPos.x, labelPos.y);
            }
        }

        function draw() {
            drawGround();
            drawRobots();
        }

        function startStream() {
            const es = new EventSource('/stream');

            es.onmessage = (event) => {
            if (!event.data) return;
            const msg = JSON.parse(event.data);

            if (msg.type === 'topology') {
                springs = msg.springs;
                nSims = msg.n_sims;
                laneSpacing = msg.lane_spacing ?? laneSpacing;
                finishX = msg.finish_x ?? finishX;
            } else if (msg.type === 'step') {
                positionsAll = msg.positions;
                comX = msg.com_x || [];
                stepT = msg.t;
                generation = msg.generation;
                bestFitness = msg.best_fitness;
                meanFitness = msg.mean_fitness;

                stepDisplay.textContent = stepT;
                genDisplay.textContent = generation;
                bestDisplay.textContent = bestFitness.toFixed(2);
                meanDisplay.textContent = meanFitness.toFixed(2);

                if (msg.fps !== undefined) {
                actualFpsDisplay.textContent = msg.fps.toFixed(0);
                }

                draw();
            }
            };

            es.onerror = (err) => console.error('EventSource error:', err);
        }

        window.addEventListener('load', () => {
            startStream();
            draw();
        });
    </script>
</body>
</html>


